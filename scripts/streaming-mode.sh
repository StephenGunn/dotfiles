#!/bin/bash
# Toggle streaming mode on/off
# Creates a sidebar with webcams and widget

STATE_FILE="/tmp/streaming-mode-active"
WIDGET_FILE="/tmp/streaming-widget"
PRIVACY_FACE="/tmp/streaming-privacy-face"
PRIVACY_TOPDOWN="/tmp/streaming-privacy-topdown"
CONFIG="$HOME/.config/streaming/config.sh"
STREAMING_CONF="$HOME/.config/hypr/streaming.conf"

# Pixelation settings (lower = more pixelated)
PIXEL_SIZE="${PIXEL_SIZE:-60}"

# Load config
if [[ -f "$CONFIG" ]]; then
    source "$CONFIG"
else
    echo "Config not found: $CONFIG"
    exit 1
fi

# Default widget if not set
WIDGET="${WIDGET:-bonsai}"

# Write streaming workspace gaps to config file
# This survives hyprctl reload
write_streaming_config() {
    local enabled="$1"

    if [[ "$enabled" == "on" ]]; then
        cat > "$STREAMING_CONF" <<EOF
# Streaming mode workspace gaps
# This file is auto-generated by streaming-mode.sh
# DO NOT EDIT MANUALLY

workspace = 1, gapsout:15 ${SIDEBAR_WIDTH} 15 15
workspace = 2, gapsout:15 ${SIDEBAR_WIDTH} 15 15
workspace = 3, gapsout:15 ${SIDEBAR_WIDTH} 15 15
workspace = 4, gapsout:15 ${SIDEBAR_WIDTH} 15 15
workspace = 5, gapsout:15 ${SIDEBAR_WIDTH} 15 15
EOF
    else
        cat > "$STREAMING_CONF" <<EOF
# Streaming mode workspace gaps
# This file is auto-generated by streaming-mode.sh
# DO NOT EDIT MANUALLY

# Streaming mode is OFF - default gaps
EOF
    fi
}

# Apply workspace gaps immediately (for instant feedback)
apply_gaps() {
    local enabled="$1"

    if [[ "$enabled" == "on" ]]; then
        hyprctl --batch "\
            keyword workspace 1,gapsout:15 ${SIDEBAR_WIDTH} 15 15; \
            keyword workspace 2,gapsout:15 ${SIDEBAR_WIDTH} 15 15; \
            keyword workspace 3,gapsout:15 ${SIDEBAR_WIDTH} 15 15; \
            keyword workspace 4,gapsout:15 ${SIDEBAR_WIDTH} 15 15; \
            keyword workspace 5,gapsout:15 ${SIDEBAR_WIDTH} 15 15"
    else
        hyprctl --batch "\
            keyword workspace 1,gapsout:15 15 15 15; \
            keyword workspace 2,gapsout:15 15 15 15; \
            keyword workspace 3,gapsout:15 15 15 15; \
            keyword workspace 4,gapsout:15 15 15 15; \
            keyword workspace 5,gapsout:15 15 15 15"
    fi
}

# Check if OBS is running (cameras would be in use)
check_obs() {
    if pgrep -x "obs" > /dev/null; then
        notify-send "Streaming Mode" "Cannot enable - OBS is running and using cameras" -u critical
        echo "Error: OBS is running. Close OBS first or use OBS for streaming instead."
        exit 1
    fi
}

# Build mpv command with low-latency settings
# Position/size handled by Hyprland window rules
# $3 = "pixelate" to enable privacy filter
mpv_webcam() {
    local device="$1"
    local title="$2"
    local privacy="$3"
    local filter_args=""

    if [[ "$privacy" == "pixelate" ]]; then
        filter_args="--vf=lavfi=[pixelize=w=${PIXEL_SIZE}:h=${PIXEL_SIZE}]"
    fi

    mpv --profile=low-latency \
        --untimed \
        --no-cache \
        --demuxer-lavf-o=fflags=+nobuffer \
        --demuxer-lavf-analyzeduration=0 \
        --demuxer-lavf-probesize=32 \
        --demuxer-lavf-o=input_format=${MPV_FORMAT},video_size=${MPV_RESOLUTION},framerate=${MPV_FRAMERATE} \
        --msg-level=ffmpeg=error \
        --no-osc --no-border --no-input-default-bindings \
        --title="$title" \
        $filter_args \
        "av://v4l2:$device" &
}

streaming_on() {
    # Check for OBS first
    check_obs

    # Write config file (survives hyprctl reload)
    write_streaming_config "on"

    # Apply gaps immediately
    apply_gaps "on"

    # Small delay for layout to adjust
    sleep 0.2

    # Start scratchpad daemon (auto-hides cams when scratchpad opens)
    pkill -f "streaming-scratchpad-daemon" 2>/dev/null
    "$HOME/dotfiles/scripts/streaming-scratchpad-daemon.sh" start &
    disown

    # Launch keystroke display (if screenkey is installed)
    if command -v screenkey &> /dev/null; then
        screenkey --position fixed \
                  --geometry "${WEBCAM_WIDTH}x${KEYS_HEIGHT}+${SIDEBAR_X}+${KEYS_Y}" \
                  --font-size medium \
                  --timeout 3 \
                  --no-systray &
    fi

    # Launch face webcam (window rules handle position/size/pin)
    if [[ -e "$CAM_FACE" ]]; then
        local face_privacy=""
        [[ -f "$PRIVACY_FACE" ]] && face_privacy="pixelate"
        mpv_webcam "$CAM_FACE" "webcam-face" "$face_privacy"
    fi

    # Launch top-down webcam (window rules handle position/size/pin)
    if [[ -e "$CAM_TOPDOWN" ]]; then
        local topdown_privacy=""
        [[ -f "$PRIVACY_TOPDOWN" ]] && topdown_privacy="pixelate"
        mpv_webcam "$CAM_TOPDOWN" "webcam-topdown" "$topdown_privacy"
    fi

    # Launch default widget
    launch_widget "$WIDGET"

    # Mark as active
    touch "$STATE_FILE"
}

streaming_off() {
    # Kill streaming windows and daemon
    pkill -f "screenkey" 2>/dev/null
    pkill -f "mpv.*webcam" 2>/dev/null
    pkill -f "streaming-scratchpad-daemon" 2>/dev/null
    kill_widget

    # Write config file (survives hyprctl reload)
    write_streaming_config "off"

    # Apply gaps immediately
    apply_gaps "off"

    # Remove state files
    rm -f "$STATE_FILE" "$WIDGET_FILE" "$PRIVACY_FACE" "$PRIVACY_TOPDOWN"
    rm -f /tmp/streaming/webcam-*-expanded /tmp/streaming-cams-hidden 2>/dev/null
}

# Restart just the webcam windows (keep gaps)
restart_cams() {
    pkill -f "mpv.*webcam" 2>/dev/null
    sleep 0.3

    if [[ -e "$CAM_FACE" ]]; then
        local face_privacy=""
        [[ -f "$PRIVACY_FACE" ]] && face_privacy="pixelate"
        mpv_webcam "$CAM_FACE" "webcam-face" "$face_privacy"
    fi
    if [[ -e "$CAM_TOPDOWN" ]]; then
        local topdown_privacy=""
        [[ -f "$PRIVACY_TOPDOWN" ]] && topdown_privacy="pixelate"
        mpv_webcam "$CAM_TOPDOWN" "webcam-topdown" "$topdown_privacy"
    fi
}

# Kill current widget by window title (more precise than pkill -f)
kill_widget() {
    hyprctl clients -j | jq -r '.[] | select(.title | startswith("streaming-")) | .pid' 2>/dev/null | while read pid; do
        [[ -n "$pid" ]] && kill "$pid" 2>/dev/null
    done
}

# Launch a widget in the bottom slot
launch_widget() {
    local widget="${1:-bonsai}"

    kill_widget
    sleep 0.2

    case "$widget" in
        bonsai)
            ghostty --title="streaming-bonsai" -e cbonsai -l -t 0.15 -i &
            ;;
        cmatrix)
            ghostty --title="streaming-cmatrix" -e cmatrix -b -s &
            ;;
        cava)
            ghostty --title="streaming-cava" -e cava &
            ;;
        pipes)
            ghostty --title="streaming-pipes" -e pipes.sh &
            ;;
        none)
            # Just kill, don't launch anything
            ;;
        *)
            echo "Unknown widget: $widget"
            echo "Available: bonsai, cmatrix, cava, pipes, none"
            return 1
            ;;
    esac

    echo "$widget" > "$WIDGET_FILE"
}

# Swap to a different widget
swap_widget() {
    local widget="$1"
    if [[ ! -f "$STATE_FILE" ]]; then
        echo "Streaming mode not active"
        return 1
    fi
    launch_widget "$widget"
}

# Restore gaps after config reload (e.g., theme switch)
# Since streaming.conf is sourced by hyprland.conf, gaps should persist
# This is mainly for ensuring config file is correct
restore_gaps() {
    if [[ ! -f "$STATE_FILE" ]]; then
        return 0  # Not active, nothing to restore
    fi

    # Ensure config file has streaming gaps
    write_streaming_config "on"
}

# Toggle privacy mode for a specific camera
# Restarts that camera with/without pixelation filter
toggle_privacy() {
    local target="$1"

    if [[ ! -f "$STATE_FILE" ]]; then
        echo "Streaming mode not active"
        return 1
    fi

    case "$target" in
        face)
            if [[ -f "$PRIVACY_FACE" ]]; then
                rm -f "$PRIVACY_FACE"
                notify-send "Privacy" "Face cam: OFF" -t 1500
            else
                touch "$PRIVACY_FACE"
                notify-send "Privacy" "Face cam: ON" -t 1500
            fi
            # Restart just face cam
            pkill -f "mpv.*webcam-face" 2>/dev/null
            sleep 0.2
            if [[ -e "$CAM_FACE" ]]; then
                local privacy=""
                [[ -f "$PRIVACY_FACE" ]] && privacy="pixelate"
                mpv_webcam "$CAM_FACE" "webcam-face" "$privacy"
            fi
            ;;
        hands|topdown)
            if [[ -f "$PRIVACY_TOPDOWN" ]]; then
                rm -f "$PRIVACY_TOPDOWN"
                notify-send "Privacy" "Hand cam: OFF" -t 1500
            else
                touch "$PRIVACY_TOPDOWN"
                notify-send "Privacy" "Hand cam: ON" -t 1500
            fi
            # Restart just topdown cam
            pkill -f "mpv.*webcam-topdown" 2>/dev/null
            sleep 0.2
            if [[ -e "$CAM_TOPDOWN" ]]; then
                local privacy=""
                [[ -f "$PRIVACY_TOPDOWN" ]] && privacy="pixelate"
                mpv_webcam "$CAM_TOPDOWN" "webcam-topdown" "$privacy"
            fi
            ;;
        both|all)
            # Toggle both to same state (if either is off, turn both on)
            if [[ -f "$PRIVACY_FACE" ]] && [[ -f "$PRIVACY_TOPDOWN" ]]; then
                rm -f "$PRIVACY_FACE" "$PRIVACY_TOPDOWN"
                notify-send "Privacy" "All cams: OFF" -t 1500
            else
                touch "$PRIVACY_FACE" "$PRIVACY_TOPDOWN"
                notify-send "Privacy" "All cams: ON" -t 1500
            fi
            restart_cams
            ;;
        *)
            echo "Usage: streaming-mode.sh privacy <face|hands|both>"
            return 1
            ;;
    esac
}

# Show current privacy status
privacy_status() {
    local face_status="OFF"
    local hands_status="OFF"
    [[ -f "$PRIVACY_FACE" ]] && face_status="ON"
    [[ -f "$PRIVACY_TOPDOWN" ]] && hands_status="ON"
    echo "Privacy mode - Face: $face_status | Hands: $hands_status"
}

# Handle arguments
case "${1:-toggle}" in
    on)
        streaming_on
        ;;
    off)
        streaming_off
        ;;
    toggle)
        if [[ -f "$STATE_FILE" ]]; then
            streaming_off
        else
            streaming_on
        fi
        ;;
    restart|refresh)
        restart_cams
        ;;
    widget)
        swap_widget "$2"
        ;;
    restore)
        restore_gaps
        ;;
    privacy)
        toggle_privacy "$2"
        ;;
    status)
        if [[ -f "$STATE_FILE" ]]; then
            echo "Streaming mode: ON"
            [[ -f "$WIDGET_FILE" ]] && echo "Widget: $(cat "$WIDGET_FILE")"
            privacy_status
            exit 0
        else
            echo "Streaming mode: OFF"
            exit 1
        fi
        ;;
    *)
        echo "Usage: streaming-mode.sh [on|off|toggle|restart|widget <name>|privacy <target>|status]"
        echo "Widgets: bonsai, cmatrix, cava, pipes, none"
        echo "Privacy: face, hands, both"
        exit 1
        ;;
esac
